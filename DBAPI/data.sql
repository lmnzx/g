-- PostgreSQL user: "s", database: "s", no password
-- createuser -s s
-- createdb -O s s
-- psql -U s -d s -f data.sql

-- two tables to test types and potentially clashing column names

create table people (
	id integer primary key generated by default as identity,
	created_at date not null default current_date,
	admin boolean not null default false,
	name text not null constraint person_name check (length(name) > 0)
);

create table things (
	id integer primary key generated by default as identity,
	person_id integer not null references people(id),
	name text not null constraint thing_name check (length(name) > 0),
	price float, -- can be null
	unique (person_id, name)
);

-- values to play with:

insert into people (admin, name) values ('t', 'Willy Wonka');
insert into people (name) values ('Charlie Buckets');
insert into things (person_id, name, price) values (1, 'chocolate bar', 3.75);
insert into things (person_id, name, price) values (1, 'keys to factory', 1000000);

-- schema, because one database is shared between many projects
-- so each project has its own schema for its API functions
create schema zz;

-- three (four?) functions to play with:

-- returns hash with 'things' key = array of hashes (or empty array)
create function zz.person(_id integer,
	out ok boolean, out js json) as $$
begin
	ok = true;
	js = row_to_json(r) from (
		select id, created_at, admin, name,
		coalesce((select json_agg(t) from (
			select id, name, price
			from things
			where things.person_id = people.id
			order by things.id
		) t), '[]') as things
		from people
		where id = $1
	) r;
	if js is null then
		ok = false;
		js = json_build_object('error', 'not found');
	end if;
end;
$$ language plpgsql;

-- returns array
create function zz.people(
	out ok boolean, out js json) as $$
begin
	ok = true;
	js = coalesce((select json_agg(r) from (
		select id, created_at, admin, name
		from people
		order by id
	) r), '[]');
end;
$$ language plpgsql;

-- overloaded function: 3 args here for things with price (see below)
create function zz.thing_add(_personid integer, _name text, _price float,
	out ok boolean, out js json) as $$
declare
	err text;
begin
	ok = true;
	with nu as (
		insert into things(person_id, name, price)
		values($1, $2, $3)
		returning id
	) select row_to_json(nu.*) into js from nu;
exception
	when others then get stacked diagnostics err = message_text;
	js = json_build_object('error', err);
	ok = false;
end;
$$ language plpgsql;

-- overloaded function: 2 args here for priceless things (see above)
create function zz.thing_add(_personid integer, _name text,
	out ok boolean, out js json) as $$
declare
	err text;
begin
	ok = true;
	with nu as (
		insert into things(person_id, name)
		values($1, $2)
		returning id
	) select row_to_json(nu.*) into js from nu;
exception
	when others then get stacked diagnostics err = message_text;
	js = json_build_object('error', err);
	ok = false;
end;
$$ language plpgsql;

